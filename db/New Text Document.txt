import os
import re
import sqlite3
import openai
import json
import datetime
from xml.etree import ElementTree as ET
from reportlab.lib.pagesizes import LETTER
from reportlab.lib.units import inch
from reportlab.platypus import (
    SimpleDocTemplate, Paragraph, Spacer, ListFlowable, ListItem
)
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.enums import TA_LEFT, TA_CENTER
from dotenv import load_dotenv

# Load environment variables
load_dotenv()
openai.api_key = os.getenv("OPENAI_API_KEY")
WRITER_MODEL = os.getenv("WRITER_MODEL", "gpt-4o")  # default fallback
FILE_NAME = os.getenv("FILE_NAME")
FULL_NAME = os.getenv("FULL_NAME")

BASE_DIR = os.path.abspath(os.path.dirname(__file__))
ROOT_DIR = os.path.dirname(BASE_DIR)
DB_DIR = os.path.join(ROOT_DIR, "db")
DB_PATH = os.path.join(DB_DIR, "data.db")
CONFIG_DIR = os.path.join(ROOT_DIR, "config")
USER_FILE = os.path.join(CONFIG_DIR, "user.json")
OUTPUT_DIR = os.path.join(ROOT_DIR, "outputs")
os.makedirs(OUTPUT_DIR, exist_ok=True)

def load_user_data():
    if not os.path.exists(USER_FILE):
        print(f"User file not found at {USER_FILE}. Please create it.")
        return {}
    with open(USER_FILE, "r", encoding="utf-8") as f:
        return json.load(f)

def ensure_jd_column():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    try:
        c.execute("ALTER TABLE processing ADD COLUMN JD TEXT")
        conn.commit()
        print("Added 'JD' column to 'processing' table.")
    except sqlite3.OperationalError:
        pass
    try:
        c.execute("ALTER TABLE processing ADD COLUMN JD_reason TEXT")
        conn.commit()
        print("Added 'JD_reason' column to 'processing' table.")
    except sqlite3.OperationalError:
        pass
    conn.close()

def process_next_writing_job():
    ensure_jd_column()
    user_data = load_user_data()
    if not user_data:
        print("No user data loaded. Cannot generate resumes/cover letters.")
        return False

    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("""
        SELECT id, url, job_data, JD, JD_reason
        FROM processing
        WHERE status='scraped'
        ORDER BY id ASC
        LIMIT 1
    """)
    row = cursor.fetchone()
    if not row:
        print("No jobs in 'scraped' status to write resumes/cover letters for.")
        conn.close()
        return False

    job_id, job_url, job_data_json, current_jd_value, jd_reason = row
    job_data = json.loads(job_data_json)
    conn.close()
    print(f"Preparing to generate resume & cover letter for job id={job_id}, url={job_url}")

    if not current_jd_value:
        approach, explanation = determine_jd_approach(job_data)
        conn = sqlite3.connect(DB_PATH)
        c2 = conn.cursor()
        c2.execute("UPDATE processing SET JD=?, JD_reason=? WHERE id=?", (approach, explanation, job_id))
        conn.commit()
        conn.close()
        current_jd_value = approach
        jd_reason = explanation
        print(f"Decided JD approach='{approach}' for job id={job_id}\nReason: {explanation}")
    else:
        print(f"JD approach already decided: {current_jd_value} for job id={job_id}")
        if jd_reason:
            print(f"Reason: {jd_reason}")

    resume_text = generate_resume_text(user_data, job_data, current_jd_value, jd_reason)
    cover_letter_text = generate_cover_letter_text(user_data, job_data, current_jd_value, jd_reason)

    job_output_dir = os.path.join(OUTPUT_DIR, str(job_id))
    os.makedirs(job_output_dir, exist_ok=True)

    resume_pdf_path = os.path.join(job_output_dir, f"{FILE_NAME}_resume.pdf")
    cover_letter_pdf_path = os.path.join(job_output_dir, f"{FILE_NAME}_coverletter.pdf")

    # Instead of "intra-paragraph" approach, we produce multiple flowables
    resume_flowables, plain_resume = parse_xml_produce_flowables(resume_text)
    cover_flowables, plain_cover = parse_xml_produce_flowables(cover_letter_text)

    create_pdf_reportlab(resume_flowables, resume_pdf_path, doc_title=FULL_NAME,
        leftMargin=0.5*inch, rightMargin=0.5*inch, topMargin=0.5*inch, bottomMargin=0.5*inch)

    create_pdf_reportlab(cover_flowables, cover_letter_pdf_path, doc_title=f"{FULL_NAME} - Cover Letter")

    conn = sqlite3.connect(DB_PATH)
    c3 = conn.cursor()
    c3.execute("""
        UPDATE processing
        SET resume=?,
            resume_pdf=?,
            cover_letter=?,
            cover_letter_pdf=?,
            status='written'
        WHERE id=?
    """, (plain_resume, resume_pdf_path, plain_cover, cover_letter_pdf_path, job_id))
    conn.commit()
    conn.close()
    return True

def determine_jd_approach(job_data):
    prompt_text = f"""
You are an AI career counselor. The user might have a Juris Doctor (JD) background.
We have the following job data:
{json.dumps(job_data, indent=2)}

Decide if the user should highlight their JD (JD-Advantage) or downplay it (JD-Light).
On the first line, output exactly one of these strings: JD-Advantage or JD-Light
On the second line, give a short reason for your choice.
"""
    resp = openai.chat.completions.create(
        model=WRITER_MODEL,
        messages=[
            {"role": "system", "content": "You are a helpful AI career counselor."},
            {"role": "user", "content": prompt_text},
        ],
        temperature=0.0, max_tokens=50
    )
    raw = resp.choices[0].message.content.strip()
    lines = raw.split('\n')
    approach = "JD-Advantage"
    explanation = "No explanation provided."
    if lines:
        first_line = lines[0].strip()
        if "light" in first_line.lower():
            approach = "JD-Light"
        elif "advantage" in first_line.lower():
            approach = "JD-Advantage"
        if len(lines) > 1:
            explanation = lines[1].strip()
    return approach, explanation

def generate_resume_text(user_data, job_data, approach, jd_reason):
    special_instructions = user_data.get("special_instructions", [])
    instructions_str = "\n".join(f"- {ins}" for ins in special_instructions)
    user_info_snippet = json.dumps(user_data, indent=2)
    job_info_snippet = json.dumps(job_data, indent=2)

    advantage_line = ""
    if approach == "JD-Advantage" and jd_reason:
        advantage_line = f"\nAdditionally, highlight how the JD is an advantage: {jd_reason}\n"

    additional_xml_line = "\nReturn the resume as valid XML inside <resume>...</resume> tags with <section>, <mybullet>, <bold>, <contact> for formatting."

    prompt_text = f"""
You are a resume writer AI. The user has a base set of experiences and wants a {approach} resume for this job.

Job Data:
{job_info_snippet}

User Data:
{user_info_snippet}

Special Instructions from user:
{instructions_str}{advantage_line}

Write a concise, ATS-friendly resume.
Include:
 - A short summary
 - Core skills relevant to the job
 - Relevant experience
 - Education

Keep it under 1 page at font size 8. Emphasize the job's required skills.
Avoid false information.
Only incorporate what's valid from the user data.
Balance the resume with the JD approach in mind.
Balance the skills, experience, and education sections accordingly.
Do not include demographic information.
Do not include eligibility status other than willingness to relocate or travel.
Include phone number, email, website, and LinkedIn profile as a single line separated by | as the first line. Do not include a name.
Do not inclue any N/A or placeholder text.
{additional_xml_line}
"""
    r = openai.chat.completions.create(
        model=WRITER_MODEL,
        messages=[
            {"role": "system", "content": "You are a helpful resume-writing assistant."},
            {"role": "user", "content": prompt_text}
        ],
        temperature=0.7, max_tokens=2000
    )
    return r.choices[0].message.content.strip()

def generate_cover_letter_text(user_data, job_data, approach, jd_reason):
    today_str = datetime.date.today().strftime("%B %d, %Y")
    special_instructions = user_data.get("special_instructions", [])
    instructions_str = "\n".join(f"- {ins}" for ins in special_instructions)
    user_info_snippet = json.dumps(user_data, indent=2)
    job_info_snippet = json.dumps(job_data, indent=2)

    advantage_line = ""
    if approach == "JD-Advantage" and jd_reason:
        advantage_line = f"\nAdditionally, mention how the JD advantage helps: {jd_reason}\n"

    additional_xml_line = "\nReturn this cover letter as valid XML inside <coverletter>...</coverletter> tags with <section>, <mybullet>, <bold>, <contact>."

    prompt_text = f"""
You are a cover letter writer AI. The user has a base set of experiences and wants a {approach} cover letter.

Job Data:
{job_info_snippet}

User Data:
{user_info_snippet}

Special Instructions from user:
{instructions_str}{advantage_line}

Today's date is {today_str}.
The cover letter should be:
 - Professional.
 - Under 1 page at 10 point font.
 - Tailored to the job.
 - Highlight the user's fit for the role.
 - Plain text only.
 - Avoid false information.
 - Include phone number, email, and LinkedIn profile directly under the signature on their own lines.
 - Include the job title and company name in the first paragraph.
 - Include the user's willingness to relocate or travel if applicable.
 - Include a call to action in the final paragraph.
 - Include how the user decided to fulfill their passion for the applicable field rather than pursuing a law career, which they are uninterested in.
 - Include today's date at the top.
 - Do not include demographic information.
 - Never use placeholders like [Date] or [Company]. If you do not possess the information, omit it.
{additional_xml_line}
"""
    r = openai.chat.completions.create(
        model=WRITER_MODEL,
        messages=[
            {"role": "system", "content": "You are a helpful cover letter-writing assistant."},
            {"role": "user", "content": prompt_text}
        ],
        temperature=0.7, max_tokens=1500
    )
    return r.choices[0].message.content.strip()

def cleanup_gpt_output(xml_text):
    lines = xml_text.split('\n')
    cleaned = []
    for line in lines:
        if line.strip().startswith('```'):
            continue
        line = line.replace('```xml', '').replace('```', '')
        cleaned.append(line)
    return "\n".join(cleaned)

def parse_xml_produce_flowables(xml_text):
    """
    1) Clean up code fences
    2) Parse <resume> or <coverletter>
    3) Return (flowables, plain_text)
       flowables -> a list[Flowable] for direct usage in story
       plain_text -> raw text for DB
    """
    text_no_fences = cleanup_gpt_output(xml_text)
    plain_text = ""
    flowables = []

    # We'll define some styles
    styles = getSampleStyleSheet()
    heading_style = ParagraphStyle(
        'Heading',
        parent=styles['Heading1'],
        fontName='Helvetica-Bold',
        fontSize=12,
        leading=14
    )
    body_style = ParagraphStyle(
        'Body',
        parent=styles['Normal'],
        fontName='Helvetica',
        fontSize=8,
        leading=12,
        alignment=TA_LEFT
    )
    contact_style = ParagraphStyle(
        'Contact',
        parent=body_style,
        alignment=TA_CENTER
    )

    try:
        root = ET.fromstring(text_no_fences)
        def process_elem(elem):
            nonlocal plain_text
            tag = elem.tag.lower()
            content = (elem.text or "").strip()
            # We'll gather child flowables in a list
            child_flows = []
            for c in elem:
                child_flows.extend(process_elem(c))

            # handle tail if any
            tail = elem.tail.strip() if elem.tail else ""

            # We'll gather flowables for this element
            this_flows = []

            if tag in ["resume", "coverletter"]:
                # top-level container
                # Return all children flows
                # Add content if any
                if content:
                    # normal paragraph
                    p = Paragraph(content, body_style)
                    this_flows.append(p)
                    plain_text += content + "\n"
                this_flows.extend(child_flows)
                if tail:
                    # tail -> new paragraph
                    p = Paragraph(tail, body_style)
                    this_flows.append(p)
                    plain_text += tail + "\n"
                return this_flows

            if tag == "section":
                # We treat <section> as a heading if there's <bold> or content
                # We'll create a heading paragraph from content
                # Then child flows below it
                if content:
                    p = Paragraph(content.upper(), heading_style)
                    this_flows.append(p)
                    plain_text += content.upper() + "\n"
                this_flows.extend(child_flows)
                if tail:
                    p = Paragraph(tail, body_style)
                    this_flows.append(p)
                    plain_text += tail + "\n"
                return this_flows

            if tag == "mybullet":
                # We'll produce a bullet line as a separate paragraph
                bullet_text = f"â€¢ {content}"
                p = Paragraph(bullet_text, body_style)
                this_flows.append(p)
                plain_text += f"- {content}\n"
                # plus any children
                this_flows.extend(child_flows)
                if tail:
                    p2 = Paragraph(tail, body_style)
                    this_flows.append(p2)
                    plain_text += tail + "\n"
                return this_flows

            if tag == "bold":
                # We'll produce bold text inline, but let's just do a paragraph for now
                # or we can create <b>content</b> markup
                bold_line = f"<b>{content}</b>"
                p = Paragraph(bold_line, body_style)
                this_flows.append(p)
                plain_text += content.upper() + "\n"
                # child flows
                this_flows.extend(child_flows)
                if tail:
                    p2 = Paragraph(tail, body_style)
                    this_flows.append(p2)
                    plain_text += tail + "\n"
                return this_flows

            if tag == "contact":
                # center line
                p = Paragraph(content, contact_style)
                this_flows.append(p)
                plain_text += content + "\n"
                this_flows.extend(child_flows)
                if tail:
                    p2 = Paragraph(tail, body_style)
                    this_flows.append(p2)
                    plain_text += tail + "\n"
                return this_flows

            # fallback
            if content:
                p = Paragraph(content, body_style)
                this_flows.append(p)
                plain_text += content + "\n"
            # children
            this_flows.extend(child_flows)
            if tail:
                p2 = Paragraph(tail, body_style)
                this_flows.append(p2)
                plain_text += tail + "\n"
            return this_flows

        flows = process_elem(root)
        flowables.extend(flows)
    except:
        # fallback => treat each line as paragraph
        for line in text_no_fences.splitlines():
            line = line.strip()
            plain_text += line + "\n"
            if line:
                # each line => paragraph
                p = Paragraph(line, getSampleStyleSheet()['BodyText'])
                flowables.append(p)

    return (flowables, plain_text.strip())

def create_pdf_reportlab(flowables, output_pdf_path, doc_title="Document",
                         leftMargin=inch, rightMargin=inch,
                         topMargin=inch, bottomMargin=inch):
    doc = SimpleDocTemplate(
        output_pdf_path, pagesize=LETTER, title=doc_title,
        leftMargin=leftMargin, rightMargin=rightMargin,
        topMargin=topMargin, bottomMargin=bottomMargin
    )
    styles = getSampleStyleSheet()

    # We'll build a story:
    from reportlab.platypus import Paragraph, Spacer

    docTitleStyle = ParagraphStyle(
        'DocTitleStyle',
        fontName='Helvetica-Bold',
        fontSize=12,
        leading=14,
        alignment=TA_CENTER
    )
    story = [
        Paragraph(doc_title, docTitleStyle),
        Spacer(1, 0.2 * inch)
    ]

    story.extend(flowables)

    doc.build(story)
    print(f"{doc_title} PDF created: {output_pdf_path}")